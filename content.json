{"meta":{"title":"Learning Grocery","subtitle":null,"description":"","author":"denlay17","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-03-30T10:13:29.000Z","updated":"2020-03-30T10:14:46.698Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-03-30T10:07:48.000Z","updated":"2020-03-30T10:18:54.131Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"浅析WebKit以及在iOS、Android的应用","slug":"浅析WebKit以及在iOS、Android的应用","date":"2020-03-31T01:57:55.000Z","updated":"2020-04-09T10:13:25.148Z","comments":true,"path":"2020/03/31/浅析WebKit以及在iOS、Android的应用/","link":"","permalink":"http://yoursite.com/2020/03/31/%E6%B5%85%E6%9E%90WebKit%E4%BB%A5%E5%8F%8A%E5%9C%A8iOS%E3%80%81Android%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、WebKitWebKit 是一个开源的 Web 浏览器引擎。广义的 WebKit 是指 WebCore，它主要包含了 HTML 和 CSS 的解析、布局和定位这类渲染 HTML 的功能逻辑。而狭义的 WebKit 就是在 WebCore 的基础上，不同平台封装 JavaScript 引擎、网络层、GPU 相关的技术（WebGL、视频）、绘制渲染技术以及各个平台对应的接口，形成我们可以用的 WebView 或浏览器。 1、WebKit架构WebKit 的一个显著特征就是支持不同的浏览器，因为不同浏览器的需求不同，所以在 WebKit 中一些代码可以共享，但是另外一部分是不同的，这些不同的部分称为 WebKit 的移植( Ports ）。 上图的 WebKit 架构，虚线框表示该部分模块在不同浏览器使用的 WebKit 内核中的实现是不同的，也就是它们不是普遍共享的。用实线框表示的部分，表示它们是基本上是共享的，但不是绝对，是因为它们中的一些特性可能并不是共享的，而且可以通过不同的编译设置改变它们的行为。 图中最下面的是操作系统，不同浏览器可能会依赖不同的操作系统，同一个浏览器使用的 WebKit 也可能依赖不同的的操作系统。 操作系统之上的就是 WebKit 赖以工作的众多第三方库，这些库是 WebKit 运行的基础。 在它们二者之上的就是 WebKit 项目了。 WebCore 包含了目前被各个浏览器所使用的 WebKit 共享部分，这些都是加载和渲染网页的基础部分，它们必不可少，包括 HTML (解释器)、CSS (解释器)、SVG、DOM、渲染树（RenderObject 树和RenderLayer 树等)，以及 Inspector(Web Inspector和调试网页)。这些共享部分有些是基础框架，其背后支持也需要各个平台的不同实现。 JavaScriptCore 引擎是 WebKit 中默认 JavaScript 引擎，也就是说一些 WebKit 的移植使用该引擎。而且它只是默认，并不是唯一的，是可以替换的。事实上，WebKit 中对 JavaScript 引擎的调用是独立于引擎的。在 Google 的 Chormium 开源项目中，它被替换成 V8 引擎。 WebKit Ports 指的是 WebKit 中的非共享部分，对于不同浏览器使用的 WebKit 来说，移植中的这些模块由于平台差异、第三方库和需求不同等原因，往往按照自己的方式来设计与实现，这就产生了移植部分，这也是导致众多 WebKit 版本的行为并非一到的重要原因。这其中包括硬件的加速架构，网络栈，视频解码，图片解码等。 在 WebCore 和 WebKit Ports 之上的层主要是提供嵌入式编程接口，这些接口是提供给浏览器、app内网页调用。图中有左右两个部分分别是狭义 WebKit （渲染机：负责各类页面的渲染）的接口和 WebKit2 的接口。因为接口与具体的移植有关，所以有一个与浏览器相关的绑定层。绑定层上面就是 WebKit 项目对外暴露的接口层。实际上接口层的定义也是与移植密切相关的，而不是 WebKit 有什么统一接口。 WebKit2相对于狭义的WebKit而言，它不是WebKit简单的第二个版本，它是一个新的API层，其最主要的变化在于将网页的渲染置于单独的进程，而接口层则在另外一个进程，它们之间通过IPC来通讯。对于接口的调用者来说，中间的IPC和底下的实现是透明的，这样做的好处有很多，一个很明显的好处是，当网页的渲染出现问题时，不会阻碍Web接口的调用者进程，这会在很大程度上解决或者帮助解决浏览器或者这些调用者的稳定性和安全性等问题。 2、WebCore二、iOS开发中的WebKit从 iOS2 开始UIWebView就作为 App 内展示 Web 内容的容器，但是长久以来一直遭受开发者的诟病，它存在系统级的内存泄露、极高内存峰值、较差的稳定性、Touch Delay 以及 JavaScript 的运行性能和通信限制等问题。在 iOS12 以后已经被标记为 Deprecated 不再维护。 在 iOS8 中，Apple 引入了新一代的 WebKit.framework，它是在 WebCore、底层桥接、JSCore 引擎等核心模块的基础上，针对 iOS 平台的项目封装，它基于新的 WKWebView，提供了一系列浏览特性的设置，以及简单方便的加载回调。提供了的WKWebView 用来替代传统的 UIWebView，它更加稳定，拥有 60fps 滚动刷新率、丰富的手势、KVO、高效的 Web 和 Native 通信，默认进度条等功能，而最重要的是，它使用了和 Safari 相同的 Nitro 引擎极大提升了 JavaScript 的运行速度。WKWebView 独立的进程管理，也降低了内存占用及 Crash 对主 App 的影响。 以项目中加载同一复杂的网页为例，使用UIWebVIew时的内存占用（一）和使用WKWebView时的内存占用（二）对比如下图所示，可以明显看到WKWebView相比UIWebView，内存占用大大减少。 1、WKWebView1.1、WKWebView的简单使用如果只是简单的加载某些网页，WKWebView的基础设置和使用与UIWebView区别不大。 1234567891011121314151617&#x2F;&#x2F; 必须引用#import &lt;WebKit&#x2F;WebKit.h&gt;...@property (nonatomic, strong) WKWebView *webView;...&#x2F;&#x2F; 初始化 (这里先使用默认的WKWebViewConfiguration设置)_webView &#x3D; [[WKWebView alloc] initWithFrame:CGRectZero configuration:[WKWebViewConfiguration new]];&#x2F;&#x2F; UI代理_webView.UIDelegate &#x3D; self;&#x2F;&#x2F; 导航代理_webView.navigationDelegate &#x3D; self;&#x2F;&#x2F; 是否允许手势左滑返回上一级, 类似导航控制的左滑返回_webView.allowsBackForwardNavigationGestures &#x3D; NO;&#x2F;&#x2F; 通过一个URL字符串构建Request对象NSMutableURLRequest *request &#x3D; [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http:&#x2F;&#x2F;www.baidu.com&quot;]];&#x2F;&#x2F; 加载Request[_webView loadRequest:request]; WKWebView的一些操作 12345678&#x2F;&#x2F; 可返回的页面列表, 存储已打开过的网页 WKBackForwardList * backForwardList &#x3D; [_webView backForwardList];&#x2F;&#x2F; 页面后退[_webView goBack];&#x2F;&#x2F; 页面前进[_webView goForward];&#x2F;&#x2F; 刷新当前页面[_webView reload]; 1.2、WKWebView的详细设置1.2.1、WKWebViewConfiguration与UIWebView不同的是，WKWebView的配置信息是被抽离出来的，如果要对网页进行更多更详细的设置，由WKWebViewConfiguration进行设置 1234567891011121314&#x2F;&#x2F; 创建网页配置对象WKWebViewConfiguration *config &#x3D; [[WKWebViewConfiguration alloc] init];&#x2F;&#x2F; 最小字体大小config.preferences.minimumFontSize &#x3D; 0;&#x2F;&#x2F;设置是否支持javaScript 默认是支持的config.preferences.javaScriptEnabled &#x3D; YES;&#x2F;&#x2F; 在iOS上默认为NO，表示是否允许不经过用户交互由javaScript自动打开窗口config.preferences.javaScriptCanOpenWindowsAutomatically &#x3D; NO;&#x2F;&#x2F; 是使用h5的视频播放器在线播放, 还是使用原生播放器全屏播放config.allowsInlineMediaPlayback &#x3D; YES;&#x2F;&#x2F; 设置视频是否需要用户手动播放，设置为NO则会允许自动播放config.requiresUserActionForMediaPlayback &#x3D; YES;&#x2F;&#x2F; 设置是否允许画中画技术 在特定设备上有效config.allowsPictureInPictureMediaPlayback &#x3D; YES; 1.2.2、WKUserScript有时需要在创建网页前，对网页进行一些修改，可以使用在初始化之前，使用WKUserScript类为网页注入JavaScript代码，如注入cookie、调整字体大小等。 12345NSString *jSString &#x3D; @&quot;xxxxxxx&quot;;&#x2F;&#x2F; 用于进行JavaScript注入WKUserScript *wkUScript &#x3D; [[WKUserScript alloc] initWithSource:jSString injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];&#x2F;&#x2F; 添加给config[config.userContentController addUserScript:wkUScript]; 1.2.3、 将设置好的WKWebViewConfiguration绑定WKWebView在设置完1.2.1、1.2.2之后，对WKWebView进行初始化，将设置好的config一并加入到初始化的网页中 1_webView &#x3D; [[WKWebView alloc]initWithFrame:CGRectZero configuration:config]; 2、WKNavigationDelegate2.1、WKNavigationDelegate与UIWebDelegate对比WKWebView的主要代理协议为WKNavigationDelegate，对比UIWebDelegate在载入URL之前的一次调用，询问开发者是否下载并载入当前URL，UIWebView只有这一次询问，而WKWebView不止在载入前询问一次，在URL下载完毕之后还会再进行一次询问，让开发者根据服务器返回的 Web 内容再次做一次确定。 12345678910111213141516171819202122#pragma mark - UIWebViewDelegate&#x2F;&#x2F; 只在请求之前发出询问是否加载- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; return YES;&#125;#pragma mark - WKNavigationDelegate&#x2F;&#x2F; 请求之前询问一次是否加载- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; &#x2F;&#x2F; 同意加载 decisionHandler(WKNavigationActionPolicyAllow); &#x2F;&#x2F; 不同意加载 &#x2F;&#x2F; decisionHandler(WKNavigationActionPolicyCancel);&#125;&#x2F;&#x2F; 得到返回的response后再询问一次是否加载- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123; &#x2F;&#x2F; 同意加载 decisionHandler(WKNavigationActionPolicyAllow); &#x2F;&#x2F; 不同意加载 &#x2F;&#x2F; decisionHandler(WKNavigationActionPolicyCancel);&#125; 同意载入之后，组件就开始下载指定URL的内容，在下载之前会调用一次开始下载回调，通知开发者Web已经开始下载。 123456789#pragma mark - UIWebViewDelegate&#x2F;&#x2F; 页面开始加载时调用- (void)webViewDidStartLoad:(UIWebView *)webView &#123; &#125;#pragma mark - WKNavigationDelegate&#x2F;&#x2F; 页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123; &#125;&#x2F;&#x2F; 当有内容开始返回时调用- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123; &#125; 页面下载完毕之后，UIWebView会直接载入视图并调用载入成功回调，而WKWebView会发询问，确定下载的内容被允许之后再载入视图。 1234567#pragma mark - UIWebViewDelegate&#x2F;&#x2F; 页面加载完成后调用- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; &#125;#pragma mark - WKNavigationDelegate&#x2F;&#x2F; 页面加载完成后调用- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123; &#125; 成功则调用成功回调，整个流程有错误发生都会发出错误回调。UIWebDelegate和WKNavigationDelegate不同的地方在于，WKNavigationDelegate将错误回调更加细化。 123456789#pragma mark - UIWebViewDelegate&#x2F;&#x2F; 页面加载失败时调用- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error &#123; &#125;#pragma mark - WKNavigationDelegate&#x2F;&#x2F; 页面加载失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123; &#125;&#x2F;&#x2F; 提交发生错误时调用- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation &#123; &#125; 2.2、WKNavigationDelegate一些新的代理2.2.1、重定向相比UIWebView，WKWebView多了一个重定向通知，在收到服务器重定向消息并且跳转询问允许之后，会回调重定向方法，这点是 UIWebView 没有的，在 UIWebView之上需要验证是否重定向，得在询问方法验证 head 信息。 123- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123; &#x2F;&#x2F; 在此进行一些重定向的操作&#125; 2.2.2、HTTPS证书自定义处理在HTTPS请求需要响应身份验证时调用 12345678910111213141516- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler&#123; &#x2F;&#x2F; 解决因证书验证失败导致的页面白屏问题 &#x2F;&#x2F; 判断服务器采用的验证方法 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; &#x2F;&#x2F; 如果没有错误的情况下 创建一个凭证，并使用证书 if ([challenge previousFailureCount] &#x3D;&#x3D; 0) &#123; NSURLCredential *credential &#x3D; [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential, credential); &#125; else &#123; &#x2F;&#x2F; 验证失败，取消本次验证 completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil); &#125; &#125; else &#123; completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil); &#125;&#125; 3、WKUIDelegateWKWebView和UIWebView另一个不同点，WKWebView新增了WKUIDelegate。在 UIWebView中，Alert、Confirm、Prompt等视图，window.open等操作是直接可执行的，但在WKWebView上，需要通过WKUIDelegate协议接收通知，然后通过iOS原生执行。 当网页内打开新网页时，会产生回调，调用-webView:createWebViewWithConfiguration:forNavigationAction: 1234567- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures&#123; &#x2F;&#x2F; 处理JS中window.open方法 if (!navigationAction.targetFrame.isMainFrame) &#123; [webView loadRequest:navigationAction.request]; &#125; return nil;&#125; 当网页内弹出Alter弹出框、Confirm确认框、Prompt输入框时，都会产生回调，然后在相应的代理方法中，转换为客户端的实现 1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F; Alter弹出框- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123; &#x2F;&#x2F; 转成UIAlterController实现 UIAlertController *alertController &#x3D; [UIAlertController alertControllerWithTitle:@&quot;弹出框&quot; message:message?:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:([UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;])]; [self presentViewController:alertController animated:YES completion:nil];&#125;&#x2F;&#x2F; Confirm确认框- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler&#123; &#x2F;&#x2F; 转成UIAlterController实现 UIAlertController *alertController &#x3D; [UIAlertController alertControllerWithTitle:@&quot;确认框&quot; message:message?:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:([UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(NO); &#125;])]; [alertController addAction:([UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(YES); &#125;])]; [self presentViewController:alertController animated:YES completion:nil];&#125;&#x2F;&#x2F; Prompt输入框- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler&#123; &#x2F;&#x2F; 转成UIAlterController实现 UIAlertController *alertController &#x3D; [UIAlertController alertControllerWithTitle:prompt message:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert]; [alertController addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.text &#x3D; defaultText; &#125;]; [alertController addAction:([UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(alertController.textFields[0].text?:@&quot;&quot;); &#125;])]; [self presentViewController:alertController animated:YES completion:nil];&#125; 4、WKWebView Native与JS的交互4.1、Native调用JSNative 调用 JS，直接依靠 WebView 提供的接口实现，WKWebView 提供的接口和 UIWebView 命名上较为类似，区别是 WKWebView 的这个接口是异步的，而 UIWebView 是同步接口。以获取网页标题为例： 123456789#pragma mark - UIWebViewNSString *title &#x3D; [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];self.title &#x3D; title; #pragma mark - WKWebView[wkWebView evaluateJavaScript:@&quot;document.title&quot; completionHandler:^(id _Nullable title, NSError * _Nullable error) &#123; self.title &#x3D; title;&#125;]; 4.2、JS调用Native对比 Native 调用 JS，JS 调用 Native 就要复杂许多 首先，JS会通过以下方法调用Native 1window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;message&gt;) Native这边，在webView初始化的时候就需要通过WKUserContentController类注册相应的JS方法 12&#x2F;&#x2F; 这里的name要与JS方法里的name一致[config.userContentController addScriptMessageHandler:self name:@&quot;name&quot;]; 而 handler 对象需要实现指定协议，实现指定的协议方法，当 JS 端通过 window.webkit.messageHandlers 发送 Native 消息时，handler 对象的协议方法被调用，通过协议方法的相关参数传值 1234#pragma mark - WKScriptMessageHandler- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; NSLog(@&quot;name:%@\\n body:%@\\n frameInfo:%@\\n&quot;,message.name,message.body,message.frameInfo);&#125; 5、WKWebView的Cookie问题5.1、关于Cookiecookie是在http协议中非常重要的角色。http是无状态协议，也就是说http不会根据之前的访问情况来处理下次请求，在很多涉及账号的网页中，页面需要根据是否登录的状态来显示内容。为了避免每次访问都要登录，可以在第一次登录完成后讲登录信息写入cookie，添加到之后的请求中，这样就解决了http不能记录状态的问题。从开发者层面来说，cookie本质是包含了一系列key-value的数组。 如图所示，客户端第一次向服务器发送请求的时候，没有cookie，服务器收到后，会生成可以表示客户端身份的cookie，服务器将cookie封装到响应包的头部的set-cookie字段，返回给客户端，客户端根据set-cookie的内容设置cookie，并在之后的请求中带上cookie内容，这样服务器就能识别到该客户端。 cookie有以下几个属性 name = value : 键值对，可以设置要保存的Key/Value（必须） domain : 可访问的域名，默认当前域名 max-age : 最大失效时间（毫秒） secure : 当secure值为true时，cookie在http中是无效，在https中才有效 path : 表示cookie能作用到的路径，如path=/。如果路径不匹配cookie也会无效 expires : 过期时间，在设置的这个时间点之后cookie就会失效。 httpOnly : 如果cookie中设置了httpOnly属性，则通过程序（JS脚本）将无法获取到cookie信息。 5.2、WKWebView的坑–Cookie丢失在使用UIWebView时，第一次请求得到响应后，会将cookie信息存到在 NSHTTPCookieStorage 中。之后的每次请求之前，都会将 NSHTTPCookieStorage 里面的cookie自动添加到请求中，因此UIWebView上的cookie问题并不突出。 在使用WKWebView时，第一次请求得到响应后，也会将cookie信息存到 NSHTTPCookieStorage 中。但是后续的请求，WKWebView并不会把 NSHTTPCookieStorage 里的cookie读取出来加到请求中，服务器在请求中拿不到cookie，请求失败。 在我遇到的问题中，解决Cookie丢失的问题方法有两个： 方案一 ：在WKWebView loadRequest 前，在 request header 中设置 Cookie； 缺陷 ：只能解决指定的一个URL的请求，涉及到同域的跳转还是会缺失cookie 123456789&#x2F;&#x2F; 在发出请求前，把cookie加到request中NSMutableURLRequest *mRequest &#x3D; (NSMutableURLRequest *) request;&#x2F;&#x2F; 获取存放在NSHTTPCookieStorage内的cookiesNSArray *cookies &#x3D; [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];NSDictionary *dict &#x3D; [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];&#x2F;&#x2F; dict中包含着cookie，只需将request的headerfields替换成dict即可mRequest.allHTTPHeaderFields &#x3D; dict;[self.wkWebView loadRequest:mRequest]; 方案二 ：在创建WKWebView之前，将cookie通过设置docume.cookie的方式，让整个页面都带上cookie 123456789101112131415161718&#x2F;&#x2F; 获取存放在NSHTTPCookieStorage内的cookiesNSArray *cookies &#x3D; [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];NSString *PHPSESSID &#x3D; [NSString string];&#x2F;&#x2F; 遍历cookies，找到需要的cookiefor( NSHTTPCookie *cookie in cookies) &#123; if([cookie.name isEqualToString:@&quot;PHPSESSID&quot;]) &#123; PHPSESSID &#x3D; cookie.value; &#125;&#125;&#x2F;&#x2F; 手动拼接documen.cookie，设置作用路径以及失效时间NSString *currentCookie &#x3D; [NSString stringWithFormat:@&quot;document.cookie &#x3D; &#39;PHPSESSID&#x3D;%@;path&#x3D;&#x2F;;max-age&#x3D;3600&#39;&quot;, PHPSESSID];&#x2F;&#x2F; JS注入WKUserScript *cookieScript &#x3D; [[WKUserScript alloc] initWithSource:currentCookie injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; WKWebViewConfiguration *config &#x3D; [[WKWebViewConfiguration alloc]init];[config.userContentController addUserScript:cookieScript];WKWebView *webView &#x3D; [[WKWebView alloc]initWithFrame:internalFrame configuration:config]; 上述两个方案一起使用，能解决绝大部分的cookie丢失问题，但是，由于WebKit对跨域进行了安全检查限制，不允许跨域，所以WKWebView在跨域请求处理时，cookie仍然会丢失。 Android开发中的WebKit","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Android","slug":"iOS/Android","permalink":"http://yoursite.com/categories/iOS/Android/"}],"tags":[{"name":"webView","slug":"webView","permalink":"http://yoursite.com/tags/webView/"}]},{"title":"关于TableView 2.0 - 具体使用","slug":"关于TableView-2-0-具体使用","date":"2020-03-30T09:58:19.000Z","updated":"2020-03-30T10:15:33.409Z","comments":true,"path":"2020/03/30/关于TableView-2-0-具体使用/","link":"","permalink":"http://yoursite.com/2020/03/30/%E5%85%B3%E4%BA%8ETableView-2-0-%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8/","excerpt":"","text":"TableView 的使用 一、为界面添加一个tableView1、添加代理并实例化一个tableView 123@interface ViewController()&lt;UITableViewDelegate, UITableViewDataSource&gt;@property (nonatomic, strong) UITableView *tableView;@end 2、懒加载tableView 12345678910111213- (UITableView *)tableView &#123; if(!_tableView)&#123; &#x2F;&#x2F; 初始化一个tableView _tableView &#x3D; [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain]; &#x2F;&#x2F; 让它与父View的宽高对齐 _tableView.autoresizingMask &#x3D; UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; &#x2F;&#x2F; 设置代理 _tableView.delegate &#x3D; self; _tableView.dataSource &#x3D; self; &#125; return _tableView;&#125; 3、将tableView添加到界面中 1234- (void)loadView &#123; [super loadView]; [self.view addSubview:self.tableView];&#125; 4、添加必须实现的方法 12345678910111213141516171819&#x2F;&#x2F;两个都是UITableViewDataSource中的代理方法&#x2F;&#x2F;设置在一个Section中包含的行的数量- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 10;&#125;&#x2F;&#x2F;添加Cell，tableView中的每一行对应一个Cell- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F;获取identifier为defaultCell的cell（复用机制） UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;defaultCell&quot;]; &#x2F;&#x2F;判断是否获取到了这个cell，获取到了直接复用，没有的话创建一个新的 if(!cell) &#123; &#x2F;&#x2F;为cell添加identifier cell &#x3D; [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;defaultCell&quot;]; &#125; &#x2F;&#x2F;给cell添加信息 cell.textLabel.text &#x3D; [NSString stringWithFormat:@&quot;这是第%ld行&quot;, indexPath.row]; return cell;&#125; 完成以上四个步骤，就能实现一个如下图所示的最基础的tableView。 系统自带的cell是不是很丑很简陋，所以接下来我们来做一个自定义仿微信的Cell布局； 二、自定义Cell这是我们要达到的效果： 1、首先创建一个继承UITableViewCell的FakeWechatCell，在FakeWechatCell.h中添加对外公开的接口 12345678@interface FakeWechatCell : UITableViewCell@property (nonatomic, strong) UIImageView *headImage;@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, strong) UILabel *detailLabel;@property (nonatomic, strong) UILabel *timeLabel;@end 2、在FakeWechatCell.m中对上面的几个控件进行布局（要先对控件进行初始化，使用的是懒加载，该处省略） 1234567891011121314151617181920212223242526272829303132- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; if(self &#x3D; [super initWithStyle:style reuseIdentifier:reuseIdentifier]) &#123; &#x2F;&#x2F; 绑定这几个控件 [self.contentView addSubview:self.headImage]; [self.contentView addSubview:self.titleLabel]; [self.contentView addSubview:self.detailLabel]; [self.contentView addSubview:self.timeLabel]; &#125; return self;&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; &#x2F;&#x2F; 对控件进行布局 [self.titleLabel sizeToFit]; [self.detailLabel sizeToFit]; [self.timeLabel sizeToFit]; &#x2F;&#x2F; 相比ViewController的布局，这里的布局都是以self.contentView为主View self.headImage.size &#x3D; CGSizeMake(40, 40); self.headImage.centerY &#x3D; self.contentView.centerY; self.headImage.left &#x3D; 15; self.titleLabel.bottom &#x3D; self.contentView.height &#x2F; 2 - 5; self.titleLabel.left &#x3D; self.headImage.right + 10; self.detailLabel.top &#x3D; self.titleLabel.bottom + 10; self.detailLabel.left &#x3D; self.titleLabel.left; self.timeLabel.right &#x3D; self.contentView.width - 15; self.timeLabel.centerY &#x3D; self.titleLabel.centerY; &#125; 3、一个简单的自定义仿微信Cell就设置完了，然后就是使用它。回到刚才的ViewController，添加三个简单的数据集合（头像、名称、详情），并为这三个数据集合添加上数据 1234567891011121314151617181920212223242526@interface ViewController()&lt;UITableViewDelegate, UITableViewDataSource&gt;@property (nonatomic, strong) UITableView *tableView;&#x2F;&#x2F; 添加三个数据集合@property (nonatomic, strong) NSMutableArray *imageArray;@property (nonatomic, strong) NSMutableArray *titleArray;@property (nonatomic, strong) NSMutableArray *detailArray;@end... - (void)viewDidLoad &#123; [super viewDidLoad]; [self createData];&#125;- (void)createData &#123; self.imageArray &#x3D; [NSMutableArray array]; self.titleArray &#x3D; [NSMutableArray array]; self.detailArray &#x3D; [NSMutableArray array]; &#x2F;&#x2F; 添加10条数据 for(int i &#x3D; 0; i &lt; 10; i++) &#123; [self.imageArray addObject:[UIImage imageNamed:@&quot;appleDark&quot;]]; [self.titleArray addObject:[NSString stringWithFormat:@&quot;第%d个好友&quot;, i]]; [self.detailArray addObject:[NSString stringWithFormat:@&quot;这是第%d个好友说的话&quot;, i]]; &#125; &#x2F;&#x2F; tableView重载数据 [self.tableView reloadData];&#125; 4、修改设置Cell的代理方法 12345678910111213- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 改用FakeWechatCell FakeWechatCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:@&quot;fakeWechatCell&quot;]; if(!cell) &#123; cell &#x3D; [[FakeWechatCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;fakeWechatCell&quot;]; &#125; &#x2F;&#x2F; 按行给Cell设置具体数据 cell.headImage.image &#x3D; self.imageArray[indexPath.row]; cell.titleLabel.text &#x3D; self.titleArray[indexPath.row]; cell.detailLabel.text &#x3D; self.detailArray[indexPath.row]; cell.timeLabel.text &#x3D; [NSDate date].description; return cell;&#125; 5、把每个Section中的Cell数量改为数据的数量，给自定义的Cell设置一个合适的高度 123456789&#x2F;&#x2F; 设置每个Section的数量- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; &#x2F;&#x2F; 也可以返回固定整数，但如果之后有删除行或添加行的操作，程序会直接崩溃，所有最好使用数据集合的数量 return self.imageArray.count;&#125;&#x2F;&#x2F; 设置每行的高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 80;&#125; 这样我们就得到了一个简单的仿微信聊天列表界面 三、tableView的三种类型在对tableView进行初始化的时候，会发现tableView有三种类型，分别为UITableViewStylePlain、UITableViewStyleGroup和UITableViewStyleInsetGrouped（iOS13 新样式）。 先将tableView的Section设为2，调用dataSource中的numberOfSectionsInTableView 123- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return 2;&#125; （1）当设为UITableViewStylePlain时，两个Section之间是没有间隔，连在一起的 （2）当设为UITableViewStyleGroup时，两个Section中间会有一个默认的间隔，如同设置界面 （3）当设为UITableViewStyleInsetGrouped时，效果如下图，cell的两边留出了空隙 三、给tableView添加Header或Footer如果使用UITableViewStylePlain样式，还想要两个Section分开，怎么办？那就给Section添加一个Header或者Footer。和Cell一样，苹果官方也给我们提供默认的Header样式，只需实现delegate中的方法，给Header定义好高度和标题，就可以得到一个默认的Header。 1234567- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 40; &#x2F;&#x2F; 高度&#125;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section &#123; return [NSString stringWithFormat:@&quot;Header %ld&quot;,section + 1]; &#x2F;&#x2F; 标题&#125; 当然，Header也是支持自定义的，简单的说，就是创建一个新的View，替换掉原来的Header。相关的API系统也开放给了开发者 123456789101112131415161718192021-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; &#x2F;&#x2F; 创建一个新的View UIView *view &#x3D; [[UIView alloc] initWithFrame:CGRectMake(0, 0, self.tableView.frame.size.width, 40)]; view.backgroundColor &#x3D; UIColor.lightGrayColor; &#x2F;&#x2F; 添加一个Label UILabel *label &#x3D; [[UILabel alloc] initWithFrame:CGRectMake(20, 0, self.tableView.frame.size.width - 20 * 2, 20)]; label.centerY &#x3D; view.centerY; label.text &#x3D; [NSString stringWithFormat:@&quot;HEADER %ld&quot;,section + 1]; label.textColor &#x3D; UIColor.whiteColor; label.font &#x3D; [UIFont systemFontOfSize:20]; &#x2F;&#x2F; 添加一个ImageView UIImageView *headerImage &#x3D; [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;appleDark&quot;]]; headerImage.contentMode &#x3D; UIViewContentModeScaleAspectFit; headerImage.size &#x3D; CGSizeMake(30, 30); headerImage.right &#x3D; view.width - 5; headerImage.centerY &#x3D; view.centerY; &#x2F;&#x2F; 加到这个view上 [view addSubview:label]; [view addSubview:headerImage]; return view;&#125; Footer的设置操作一样 另外两种tableView的样式一样，也可以设置Header和Footer。不同的地方在于，在滑动tableView时，设置为Plain的Header，会一直在屏幕顶部显示，直到该Section中的Cell全部滑出屏幕，才会显示下一个Header。而另外两个样式的Header，会随着滑动，滑出屏幕。 四、tableView的各种操作（1） cell点击事件 （最常用）1234- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 此处编写点击后的相关响应事件 NSLog(@&quot;点击了第%ld行&quot;, indexPath.row);&#125; （2）tableView的编辑模式 我们先将section数量改回1，Header相关代码屏蔽 1、添加、删除要进入编辑模式，首先要先添加一个能够进入编辑模式的按钮，通常选择导航栏的左按钮(self.navigationItem.leftBarButtonItem)或右按钮(rightBarButtonItem)，还需要通过UITableView的setEditing:animated:方法来控制其进入和退出编辑模式。当tableView处于编辑模式时，在Cell的最左边会出现“+”或者“-”的图标。 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; ... &#x2F;&#x2F; 选择导航栏的右按钮作为编辑按钮 self.navigationItem.rightBarButtonItem &#x3D; self.editButtonItem; ...&#125;...- (void) setEditing:(BOOL)editing animated:(BOOL)animated &#123; [super setEditing:editing animated:animated]; [self.tableView setEditing:editing animated:animated];&#125; 当调用了setEditing方法之后，tableView会陆续调用dataSource和delegate的几个方法，具体执行次序如下： 1） tableView对象首先调用UITableViewDataSource的tableView:canEditRowAtIndexPath:方法（可选，可将某行设置为不可编辑，如果不作处理，默认所有行可编辑），例如： 12345678- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 除了第2行，其他行都可以进行编辑 if(indexPath.row &#x3D;&#x3D; 1) &#123; return NO; &#125;else &#123; return YES; &#125;&#125; 2） 然后tableView对象首先调用delegate对象的tableView:editingStyleForRowAtIndexPath:方法（必选），该方法返回行所要显示的控件类型，即删除或插入控件。 1234567891011- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if(indexPath.row % 2 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 插入控件 return UITableViewCellEditingStyleInsert; &#125;else &#123; &#x2F;&#x2F; 删除控件 点击删除控件时，会在cell尾部出现一个delete按钮，点击按钮后调用commitEditingStyle:方法 &#x2F;&#x2F; 添加删除控件的cell，不用进入编辑模式，在正常模式下，左滑cell也能出现点击删除控件的效果 return UITableViewCellEditingStyleDelete; &#125;&#125;&#x2F;&#x2F; 第二个cell设置为不可编辑，所以没有变化 系统还提供了直接更改delete按钮文本的方法 123- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return @&quot;要删除吗&quot;;&#125; 3） 接着，在tableView中的row左边会显示响应的控件，此时用户可以进行操作； 4）当用户对cell的编辑控件进行点击时，会调用dataSource的tableView:commitEditingStyle:forRowAtIndexPath:方法（必选），用户即可实现该方法，从而实现希望完成的操作，如删除或添加某一行，我在此只做了简单的打印。 12345678910- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 点击删除控件的响应 if(editingStyle &#x3D;&#x3D; UITableViewCellEditingStyleDelete) &#123; NSLog(@&quot;删除了第%ld行&quot;, indexPath.row); &#125; &#x2F;&#x2F; 点击添加按钮的响应 else if(editingStyle &#x3D;&#x3D; UITableViewCellEditingStyleInsert) &#123; NSLog(@&quot;点击了第%ld行的添加按钮&quot;, indexPath.row); &#125;&#125; 2、多选在调用delegate的tableView:editingStyleForRowAtIndexPath:方法设置编辑控件时，如果将两种类型进行位运算，会变为选择控件，如下图所示 1return UITableViewCellEditingStyleInsert | UITableViewCellEditingStyleDelete; 系统自带的多选功能，不用开发者去自己去获取选中的行，只需调用[self.tableView indexPathsForSelectedRows]方法就可以获取到 1234567891011121314151617&#x2F;* * 多行删除代码示例 *&#x2F;NSMutableIndexSet *indexSets &#x3D; [[NSMutableIndexSet alloc] init];&#x2F;&#x2F; 获取选中行的索引[[self.tableView indexPathsForSelectedRows] enumerateObjectsUsingBlock:^(NSIndexPath * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [indexSets addIndex:obj.row];&#125;];&#x2F;&#x2F; 根据索引批量删除数据集合中的相应数据[self.imageArray removeObjectsAtIndexes:indexSets];[self.titleArray removeObjectsAtIndexes:indexSets];[self.detailArray removeObjectsAtIndexes:indexSets];&#x2F;&#x2F; 根据选中行删除相应的Cell，不需再调用[self.tableView reloadData]，删除操作完成后自动执行[self.tableView deleteRowsAtIndexPaths:[self.tableView indexPathsForSelectedRows] withRowAnimation:UITableViewRowAnimationFade]; 3、移动除了可以对行进行添加、删除、选择，还可以进行对行进行移动，交换行的顺序等操作。需要调用dataSource中的tableView:canMoveRowAtIndexPath:方法和tableView:moveRowAtIndexPath:toIndexPath:方法。 123456789101112&#x2F;&#x2F; 与编辑的canEditRowAtIndexPath:不同，要实现移动操作，该方法必须调用- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath &#123; if(indexPath.row &#x3D;&#x3D; 1) &#123; return NO; &#125;else &#123; return YES; &#125;&#125;&#x2F;&#x2F; 该方法也必须调用- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath &#123; NSLog(@&quot;移动了第%ld行&quot;, indexPath.row);&#125; 效果如图所示： 4、自定义左滑或右滑显示的按钮系统提供的控件只能满足一般的需求。在日常工作中，就有更多的需求，就拿微信举例，当用户左滑cell的时候，就会有“标为未读”和“删除”两个按钮。下面我们就来仿照微信，实现这两个按钮。 其实要实现这个两个效果很简单，只需调用tableView:trailingSwipeActionsConfigurationForRowAtIndexPath:方法，（右滑的话调用tableView:leadingSwipeActionsConfigurationForRowAtIndexPath:） 12345678910111213141516171819202122232425262728293031- (UISwipeActionsConfiguration *)tableView:(UITableView *)tableView trailingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 定义“标为未读”按钮事件 UIContextualAction *setAction &#x3D; [UIContextualAction contextualActionWithStyle:UIContextualActionStyleDestructive title:@&quot;标为未读&quot; handler:^(UIContextualAction * _Nonnull action, __kindof UIView * _Nonnull sourceView, void (^ _Nonnull completionHandler)(BOOL)) &#123; &#x2F;&#x2F; 在这里实现点击“标为未读”时的响应事件 NSLog(@&quot;第%ld行标为未读&quot;,indexPath.row); &#x2F;&#x2F; 是否响应该操作 completionHandler(YES); &#125;]; &#x2F;&#x2F; 设置背景色 setAction.backgroundColor &#x3D; UIColor.grayColor; &#x2F;&#x2F; 定义“删除”按钮事件 UIContextualAction *deleteAction &#x3D; [UIContextualAction contextualActionWithStyle:UIContextualActionStyleDestructive title:@&quot;删除&quot; handler:^(UIContextualAction * _Nonnull action, __kindof UIView * _Nonnull sourceView, void (^ _Nonnull completionHandler)(BOOL)) &#123; &#x2F;&#x2F; 实现点击“删除”时的响应事件 &#x2F;&#x2F; 根据索引删除数据集合中的数据 [self.imageArray removeObjectAtIndex:indexPath.row]; [self.titleArray removeObjectAtIndex:indexPath.row]; [self.detailArray removeObjectAtIndex:indexPath.row]; &#x2F;&#x2F; 根据索引删除行 [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; completionHandler(YES); &#125;]; &#x2F;&#x2F; 背景色 deleteAction.backgroundColor &#x3D; UIColor.redColor; &#x2F;&#x2F; 将两个按钮事件绑定，第一个添加的按钮事件会在最右侧 UISwipeActionsConfiguration *config &#x3D; [UISwipeActionsConfiguration configurationWithActions:@[deleteAction,setAction]]; &#x2F;&#x2F; 如果设置为YES，从右向左完全滑动cell时，第一个按钮事件会自动执行 config.performsFirstActionWithFullSwipe &#x3D; NO; return config;&#125; 这两个按钮事件会完全替换掉之前的delete按钮，在编辑模式下，点击“-”按钮，也会出现这两个按钮； 5、双指下滑进行多选（iOS13 新功能）iOS13多了一个双指下滑进行多选的新功能，也为开发者提供了相应的api，实现的方法也很简单。 （1）首先将tableView的allowsMultipleSelectionDuringEditing属性设置为YES； 1_tableView.allowsMultipleSelectionDuringEditing &#x3D; YES; 注意：当allowsMultipleSelectionDuringEditing属性设置为YES后，tableView:editingStyleForRowAtIndexPath:设置的编辑类型会失效，编辑类型被强制设置为选择类型 （2）接着调用delegate中的tableView: shouldBeginMultipleSelectionInteractionAtIndexPath:方法，在这个方法中可以设置对某行的限制 123- (BOOL)tableView:(UITableView *)tableView shouldBeginMultipleSelectionInteractionAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125; 但如果之前在tableView:canEditRowAtIndexPath: 方法中对某行已经做了限制，如我们之前已经对第二行做了不可编辑的限制，那么这一方同样也不会被选中。 （3）最后我们调用delegate的tableView: didBeginMultipleSelectionInteractionAtIndexPath:方法，在方法中添加开始选中后的相关操作 12345- (void) tableView:(UITableView *)tableView didBeginMultipleSelectionInteractionAtIndexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 虽然双指进行多选可以对行进行编辑，但仍需开发者手动让tableView进入编辑模式 &#x2F;&#x2F; 进入编辑模式 [self setEditing:YES animated:YES];&#125; 参考文档[UITableView 编辑模式详解]； [苹果开发者文档] [个人编写的demo]","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"tableView","slug":"tableView","permalink":"http://yoursite.com/tags/tableView/"}]},{"title":"浅谈Core-Location及其使用","slug":"浅谈Core-Location及其使用","date":"2020-03-30T09:56:17.000Z","updated":"2020-03-30T10:15:51.622Z","comments":true,"path":"2020/03/30/浅谈Core-Location及其使用/","link":"","permalink":"http://yoursite.com/2020/03/30/%E6%B5%85%E8%B0%88Core-Location%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Core Location 定位方式iOS的定位分为三种： GPS定位 通过GPS卫星获取定位信息，定位精度最高，但定位速度最慢，耗电量也最大。当用户在室内或地下车库等有遮挡的环境时，GPS定位的准确度就会大打折扣。 基站信号定位 每个手机基站都有一个标识符，iOS设备可以搜集周围所有收到信号的基站和它们的标识符，通过联网发送到苹果云端服务器，再由服务器根据这些基站的的位置信息查询并计算出当前位置，然后返回给手机。因为基站信号辐射范围大，所以定位精度低，500m到几公里都是有可能的，但定位速度快，耗电量低。 Wi-Fi定位 与基站定位原理相似, iOS设备通过无线网卡检测手机周围所有的WIFI热点（不需要连接上，只需要有信号就行），获得它们的MAC地址，然后到苹果云端服务器查询这个热点是否已经登记，登记过的话它的位置信息是多少，最后通过计算得到当前位置并返回给iOS设备。精度介于GPS定位和基站信号定位之间，经过测试，精度基本保持在30m到65m左右。 iOS设备采用的定位方式完全由系统决定。 CLLocationManagerCLLocationManager类是为APP配置位置相关事件和方向相关事件的类，使用该类的实例来配置方向事件和位置事件的参数，这些参数决定了何时启用或者停止事件的传递、事件何时响应，也可以使用该类的实例来检索最近的位置数据和方向数据。 locationManager为位置相关的活动所提供以下支持： 基于精确度来追踪用户当前位置的大范围或小范围的改变； 监听不同的Region区域并在用户进入或离开这些Region区域时生成响应事件； 通过指南针报告航向变化。 使用CLLocationManager申请定位权限iOS的APP在使用定位服务时，需要先向用户申请定位权限。开发者需要在info.plist中添加： 如果想要APP在后台也能使用定位服务，还要获取后台定位的权限，设置如图所示： 实例化并懒加载一个locationManager1、在.h文件中引用&lt;CoreLocation/CoreLocation.h&gt; 1#import &lt;CoreLocation&#x2F;CoreLocation.h&gt; 2、实例化一个CLLocationManager 1@property (nonatomic, strong) CLLocationManager *locationManager; 3、懒加载locationManager 1234567891011121314151617181920212223- (CLLocationManager *)locationManager &#123; if (!_locationManager) &#123; _locationManager &#x3D; [CLLocationManager new]; if ([_locationManager respondsToSelector:@selector(allowsBackgroundLocationUpdates)]) &#123; &#x2F;&#x2F; APP在后台是否能使用定位 [_locationManager setAllowsBackgroundLocationUpdates:YES]; &#125; if (@available(iOS 11.0, *)) &#123; &#x2F;&#x2F; 是否改变导航栏样式 [_locationManager setShowsBackgroundLocationIndicator:NO]; &#125; &#x2F;&#x2F; 是否可以暂停位置更新 _locationManager.pausesLocationUpdatesAutomatically &#x3D; NO; &#x2F;&#x2F; 定位精度，精度越高，耗电量越大 &#x2F;&#x2F; 如果项目开发时，只需获取用户的国家或城市等较大范围的位置信息，desiredAccuracy仅需设置为低精度即可，以达到省电的目的。若需要精确到街道甚至更加详细的位置，则需要高精度。 _locationManager.desiredAccuracy &#x3D; kCLLocationAccuracyNearestTenMeters; &#x2F;&#x2F; 位置更新最小移动距离 &#x2F;&#x2F; 与desiredAccuracy相同，若要求精确度不高，则可以将该值设置为较大的数值 _locationManager.distanceFilter &#x3D; kXBDistanceFilterTwentyMeters; _locationManager.delegate &#x3D; self; &#125; return _locationManager;&#125; 常用方法和代理方法1、在开始使用定位服务之前，需要先注册APP的定位权限 123456789101112131415161718192021222324252627... &#x2F;&#x2F; 获取当前定位权限 CLAuthorizationStatus status &#x3D; [CLLocationManager authorizationStatus]; &#x2F;&#x2F;根据现有权限进行操作 switch (status) &#123; case kCLAuthorizationStatusAuthorizedWhenInUse:&#x2F;&#x2F;使用APP期间定位 case kCLAuthorizationStatusAuthorizedAlways:&#x2F;&#x2F;一直定位 [self.locationManager startUpdatingLocation]; break; case kCLAuthorizationStatusDenied: &#x2F;&#x2F; 用户拒绝使用定位，可在此引导用户开启 NSLog(@&quot;用户拒绝使用定位&quot;); break; case kCLAuthorizationStatusRestricted: &#x2F;&#x2F; 权限受限，可引导用户开启 break; case kCLAuthorizationStatusNotDetermined: &#x2F;&#x2F; 未选择，一般是首次启动，根据需要发起申请 &#x2F;&#x2F; 向系统请求在使用APP时的定位服务权限 [self.locationManager requestWhenInUseAuthorization]; &#x2F;&#x2F; 向系统请求定位权限，不论APP在前台还是在后台 [self.locationManager requestAlwaysAuthorization]; break; default: break; &#125;... 当用户更改了APP的定位权限时，locationManager会调用代理方法-locationManager:didChangeAuthorizationStatus: 12345678910111213141516171819- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status&#123; switch (status) &#123; case kCLAuthorizationStatusAuthorizedWhenInUse:&#x2F;&#x2F;使用APP期间定位 case kCLAuthorizationStatusAuthorizedAlways:&#x2F;&#x2F;一直定位 [manager startUpdatingLocation]; break; case kCLAuthorizationStatusDenied: &#x2F;&#x2F; 用户拒绝使用定位，可在此引导用户开启 break; case kCLAuthorizationStatusRestricted: &#x2F;&#x2F; 权限受限，可引导用户开启 break; case kCLAuthorizationStatusNotDetermined: &#x2F;&#x2F; 未选择，在代理方法里，一般不会有这个状态，如果有，再次发起申请 break; default: break; &#125;&#125; 2、在适当位置添加开始或结束定位服务，开始或结束重大位置更新监测等 12345678910... &#x2F;&#x2F;开始定位 [self.locationManager startUpdatingLocation]; &#x2F;&#x2F;结束定位 [self.locationManager stopUpdatingLocation]; &#x2F;&#x2F;开始重大位置更新监测 [self.locationManager startMonitoringSignificantLocationChanges]; &#x2F;&#x2F;结束重大位置更新监测 [self.locationManager stopMonitoringSignificantLocationChanges] ... 3、当用户移动了之前设置的距离（_locationManager.distanceFilter）后，locationManager会通知代理有了新的位置，然后在-locationManager:didUpdateLocations:中对新的位置信息进行下一步操作。新的位置信息通常是一个集合，一般使用该集合的最后一项作为最新位置。 12345678910&#x2F;&#x2F; 通知代理有新的可用位置值，即当位置管理获取到新的位置后，在此进行进一步操作- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations&#123; CLLocation *location &#x3D; location.lastObject; NSLog(@&quot;位置更新,精度:%f,当前位置:经度:%f,纬度:%f&quot;, location.horizontalAccuracy, location.coordinate.latitude,location.coordinate.longitude);&#125;&#x2F;&#x2F; 当locationManager无法检测到位置值时通知代理- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error&#123; NSLog(@&quot;定位服务错误&quot;);&#125; CLRegionCLRegion是表示可监测区域的类。以一个具体的位置值(CLLocationCoordinate2D)为中心绘制的圆形区域。每个区域都有独一无二的identifier，如果出现了重复的identifier，新的Region会将旧Region替换掉。 添加的监测区域Region是系统级的，除非手动注销或设备关机，注册的Region将一直存在。所以为了节省设备资源，每个APP都有Region的数量限制，当Region的数量超过20个后，系统将只会对最新的20个Region进行监测。 1、添加一个监测区域(Region) 123456789101112&#x2F;&#x2F; 定义一个CLLocationCoordinate2D作为区域的圆心CLLocationCoordinate2D center;center.latitude &#x3D; 22;center.longitude &#x3D; 11;&#x2F;&#x2F; 使用CLCircularRegion创建一个圆形区域，半径为50米&#x2F;&#x2F; 初始化时使用CLCircularRegionCLRegion *region1 &#x3D; [[CLCircularRegion alloc] initWithCenter:center radius:50 identifier:@&quot;region1&quot;];&#x2F;&#x2F; 开始监听区域[self.locationManager startMonitoringForRegion:region1]; 2、当用户进入某个监测区域时，locationManager会通知代理，然后在-locationManager:didEnterRegion:中进行操作： 123456- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region&#123; if([region.identifier isEqualToString:@&quot;region1&quot;]) &#123; NSLog(@&quot;进入监测区域region1&quot;); &#125;&#125; 3、当用户离开某个监测区域时，locationManager同样会通知代理，然后在-locationManager:didExitRegion:中进行操作： 123456- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region&#123; if([region.identifier isEqualToString:@&quot;region1&quot;]) &#123; NSLog(@&quot;离开监测区域region1&quot;); &#125;&#125; 4、当locationManager调用-requestStateForRegion:方法时，会通知代理，然后在-locationManager:didDetermineState: forRegion:中返回用户当前位置与监测区域Region的位置关系 12345678910111213141516171819... &#x2F;&#x2F; 获取到指定region（根据唯一值identifier） [self.locationManager.monitoredRegions enumerateObjectsUsingBlock:^(__kindof CLRegion * _Nonnull obj, BOOL * _Nonnull stop) &#123; if([obj.identifier isEqualToString:@&quot;region1&quot;])&#123; [self.locationManager requestStateForRegion:obj]; &#125; &#125;];...- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region&#123; if([region.identifier isEqualToString:@&quot;region1&quot;])&#123; if(state &#x3D;&#x3D; CLRegionStateUnknown)&#123; NSLog(@&quot;状态未知&quot;); &#125;else if(state &#x3D;&#x3D; CLRegionStateInside)&#123; NSLog(@&quot;用户在region1圈内&quot;) &#125;else if(state &#x3D;&#x3D; CLRegionStateOutside)&#123; NSLog(@&quot;用户在region1圈外&quot;); &#125; &#125;&#125; 一些注意的点1、当用户越过Region边界时（不论是进入监测区域还是离开监测区域），如果APP在未启动状态，系统会将APP启动，所以如果明确了不需要继续使用定位服务，应使用-stopUpdatingLocation 手动停止定位服务以及使用以下代码注销监测区域： 12345[self.locationManager.monitoredRegions enumerateObjectsUsingBlock:^(__kindof CLRegion * _Nonnull obj, BOOL * _Nonnull stop) &#123; if([obj.identifier isEqualToString:@&quot;region1&quot;])&#123; [self.locationManager stopMonitoringForRegion:obj]; &#125;&#125;]; 2、获取到的location精确度与用户手机蜂窝信号、Wi-Fi信号以及GPS信号的强弱都有联系。即使用户的真实地理位置没有改变，也会出现由于定位精度低，设备获取到的用户位置发生改变的情况。所以在获取定位位置时，可以在-locationManager:didUpdateLocations:中对获取到的位置信息进行过滤，以获得最佳位置信息。 3、在添加监测区域Region的时候，有时由于点2所述情况，用户的位置会在短时间内发生变化，如果此时用户位置已经在Region圈内，那么将不会触发-locationManager:didEnterRegion:，即没有入圈的动作。同样的，如果用户位置已在圈外，也不会触发出圈动作。如果在实际的项目开发中，需要靠出入圈唤醒APP以及其他更多的操作，为避免上述问题，通常会使用多个同心圆的监测区域，同时进行监测。监测区域Region的半径也不宜过小，根据官方文档以及个人开发经验，最外层的Region半径最好不低于200m。 参考文档1、苹果开发者文档-Core Location 2、CSDN-iOS CLRegion监听区域 3、简书-iOS定位的3种方式(方式) 4、苹果开发者文档-Region Monitoring and iBeacon 5、一些个人Demo","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"定位","slug":"定位","permalink":"http://yoursite.com/tags/%E5%AE%9A%E4%BD%8D/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-30T07:45:01.601Z","updated":"2020-03-30T07:45:01.601Z","comments":true,"path":"2020/03/30/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Android","slug":"iOS/Android","permalink":"http://yoursite.com/categories/iOS/Android/"}],"tags":[{"name":"webView","slug":"webView","permalink":"http://yoursite.com/tags/webView/"},{"name":"tableView","slug":"tableView","permalink":"http://yoursite.com/tags/tableView/"},{"name":"定位","slug":"定位","permalink":"http://yoursite.com/tags/%E5%AE%9A%E4%BD%8D/"}]}